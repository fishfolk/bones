searchState.loadedDescShard("bones_ecs", 0, "Bones ECS\nCreates an instance of the type this trait is implemented …\nHelper trait for unwraping each item in an array.\nThe <code>World</code> is simply a collection of <code>Resources</code>, and …\nAtomic Refcell implmentation.\nBitset implementation.\nBorrow a component store from the world.\nMutably borrow a component store from the world.\nECS component storage.\nStores the world components.\n<code>Entity</code> implementation, storage, and interation.\nGet an entity’s components.\nReturns the argument unchanged.\nCreates <code>Self</code> using data from the given <code>World</code>.\nGet an entity’s components.\nBorrow a resource from the world, if it exists.\nBorrow a resource from the world, if it exists.\nInitialize a resource of type <code>T</code> by inserting it’s …\nInsert a resource.\nCalls <code>U::from(self)</code>.\nRemove the component info for dead entities.\nCreate a new <code>World</code>.\nThe prelude.\nProvides an interface for resetting entities, and …\nBorrow a resource from the world.\nBorrow a resource from the world.\nWorld resource storage.\nStores the world resources.\nRun a system once.\nImplementation of stage abstraction for running …\nImplements the system API for the ECS.\nUnwrap all the items in an array.\nCreate a new world that uses the provided entities …\nA mutable memory location with dynamically checked borrow …\nWrapper for a borrowed <code>AtomicCell</code> that will released lock …\nWrapper for mutably borrowed <code>AtomicCell</code> that will released …\nThis module contains types that can be used to implement …\nEncapsulates shared borrowing state.\nEncapsulates exclusive borrowing state.\nLock type used by [<code>AtomicCell</code>].\nReturns true if there are too many read refs.\nReturns true if there are too many write refs.\nClones immutable borrow of specified lock. This function …\nClones mutable borrow of specified lock. This function …\nReturns true if specified lock value is borrowed.\nReturns true if specified lock value is borrowed immutably.\nReturns true if specified lock value is borrowed mutably.\nCreate atomic borrow lock. Initially not borrowed.\nReleases immutable borrow of specified lock. This function …\nReleases mutable borrow of specified lock. This function …\nAttempts to borrow specified lock immutably.\nAttempts to borrow specified lock mutably.\nBitSet formatter.\nThe BitSet API.\nThe type of bitsets used to track entities in component …\nReturns if all bits are set.\nBitwise AND.\nBitwise AND after NOT of rhs.\nReturns if any bits are set.\nConditionally sets or resets the given bit.\nCounts the number of set bits.\nReturns if the two bitsets have no bits in common.\nReturns if the two bitsets are equal.\nFlips the given bit.\nFormat the bits.\nInitializes all bits.\nReturns total number of bits.\nBitwise combine with MASK.\nReturns if none of the bits are set.\nBitwise NOT.\nBitwise OR.\nResets the given bit.\nSets the given bit.\nReturns if self is a subset of rhs.\nReturns if self is a superset of rhs.\nReturns if the given bit is set.\nBitwise XOR.\nShorthand for combining bitsets with bit_or.\nShorthand for setting bits on the bitset container.\nCheck whether or not the bitset contains the given entity.\nCreates a bitset big enough to contain the index of each …\nReturns the argument unchanged.\nReturns the argument unchanged.\nImplements the <code>BitSet</code> trait members for your type through …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet an entity on the the bitset.\nAn atomic component store.\nRead-only iterator over components matching a given bitset\nMutable iterator over components matching a given bitset\nRead-only iterator over components matching a given bitset.\nMutable iterator over components matching a given bitset. …\nThis trait factors out functions for iterating with bitset …\nA typed wrapper around <code>UntypedComponentStore</code>.\nA collection of <code>ComponentStore&lt;T&gt;</code>.\nAn untyped atomic component store.\nIterates over components using a provided bitset. Each …\nIterates over components using a provided bitset. Each …\nIterate over component store returning …\nIterate mutably over component store returning …\nHolds components of a given type indexed by <code>Entity</code>.\nMutable iterator over pointers in an untyped component …\nMutable iterator over pointers in an untyped component …\nGet bitset of <code>ComponentStore</code> / implementor.\nReturns the bitset indicating which entity indices have a …\nRead the bitset containing the list of entites with this …\nGet <code>ComponentStore</code> for usage with generic types …\nThe number of components (enabled bits in the <code>inner</code> …\nThe number of components (enabled bits in the <code>inner</code> …\nCheck whether or not this component store has data for the …\nCheck whether or not this component store has data for the …\nCreate an <code>UntypedComponentStore</code> that is valid for the …\nThe number of enabled bits discovered in the query bitset. …\nThe number of enabled bits discovered in the query bitset. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>ComponentStore</code> from an <code>UntypedComponentStore</code>.\nGet a reference to the component storage for the given …\nGets an immutable reference to the component of <code>Entity</code>.\nBorrow a component store.\nGet the untyped component storage by the component’s …\nGet the components of a certain type\nGet the untyped component storage by the component’s …\nGet mutable references s to the component data for …\nGet mutable references to the component data for multiple …\nGet <code>SchemaRefMut</code>s to the component data for multiple …\nGet a mutable reference to the component storage for the …\nGets a mutable reference to the component of <code>Entity</code>.\nGet a mutable reference to component storage for the given …\nGet a mutable reference to component if it exists. …\nGet a <code>SchemaRef</code> to the component for the given <code>Entity</code> if …\nGet a <code>SchemaRefMut</code> to the component for the given <code>Entity</code>\nGets a mutable reference to the component if there is …\nGets a mutable reference to the component if there is …\nGets an immutable reference to the component if there is …\nGet a reference to the component store if there is exactly …\nGets an immutable reference to the component if there is …\nGets an immutable reference to the component if there is …\nGet a mutable reference to the component store if there is …\nGets a mutable reference to the component if there is …\nThe component bitset iterator.\nThe component bitset iterator.\nInsert component data for the given entity and get the …\nInserts a component for the given <code>Entity</code> index. Returns …\nInsert component data for the given entity and get the …\nReturns true if the entity already had a component of this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into a typed <code>ComponentStore</code>.\nConverts to the internal, untyped <code>ComponentStore</code>.\nIterates immutably over all components of this type.\nIterates immutably over all components of this type. Very …\nIterates mutably over all components of this type.\nIterates mutably over all components of this type. Very …\nIterates mutable over the components of this type where …\nIterates mutable over the components of this type where …\nIterates mutable over the components of this type where …\nIterates mutably over the components of this type where …\nIterates mutably over the components of this type where …\nIterates mutably over the components of this type where …\nIterates immutably over the components of this type where …\nIterates immutably over the components of this type where …\nIterates immutably over the components of this type where …\nIterates immutably over the components of this type where …\nIterates immutably over the components of this type where …\nIterates immutably over the components of this type where …\nCreate a arbitrary <code>UntypedComponentStore</code>.\nThe number of enabled bits in the input bitset.\nThe number of enabled bits in the input bitset.\nRemove the component data for the entity if it exists.\nRemoves the component of <code>Entity</code>. Returns <code>Some(T)</code> if the …\nRemove the component data for the entity if it exists.\nIf there is a previous value, <code>true</code> will be returned.\nGet the schema of the components stored.\nGet a reference to the component storage for the given …\nGet mutable references s to the component data for …\nGet a mutable reference to the component storage for the …\nInsert component data for the given entity and get the …\nInsert component data for the given entity and get the …\nRemove the component data for the entity if it exists.\nHolds a list of alive entities.\nIterator over entities returned by <code>Entities::iter_with</code>.\nAn entity index.\nIterator over entities using the provided bitset.\nThe type of iterator this query item creates\nMore than one entity matches the query.\nNo entity matches the query.\nHelper func to construct a <code>OptionalQueryItem</code> wrapping a …\nHelper func to construct a <code>OptionalQueryItemMut</code> wrapping a …\nWrapper for the <code>Comp</code> <code>SystemParam</code> used as <code>QueryItem</code> to …\nWrapper for the <code>CompMut</code> <code>SystemParam</code> used as <code>QueryItem</code> to …\nA type representing a component-joining entity query.\nAn error that may occur when querying for a single entity. …\nReturns a list of all <code>Entity</code>s cloned into a new vec.\nModify the iteration bitset\nReturns a bitset where each index where the bit is set to …\nClears the killed entity list.\nCreates a new <code>Entity</code> and returns it.\nGet the first entity and components in the given query.\nGet the first entity in the given bitset.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the generation of this <code>Entity</code>.\nGet the first entity and components in the given query.\nGet the first entity in the given bitset.\nGet a single entity and components in the given query if …\nReturn the item that matches the query within the given …\nReturns the index of this <code>Entity</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if the <code>Entity</code> is still alive.\nIterates over all alive entities.\nIterate over the entities and components in the given …\nReturn an iterator over the provided bitset.\nIterates over entities using the provided bitset.\nKill an entity.\nKills all entities.\nReturns entities in the killed list.\nCreates a new <code>Entity</code> from the provided index and …\nGet a single entity and components in the given query if …\nA mutable memory location with dynamically checked borrow …\nThe BitSet API.\nA <code>bool</code>\nA boolean.\nA <code>bool</code>\nThe represents a <code>SchemaBox</code> with given type inside.\nError creating ID\nDerive macro for deriving <code>Deref</code> on structs with one field.\nDerive macro for deriving <code>DerefMut</code> on structs with one …\nAccess an enum.\nType represents an enum, which in the C layout is called a …\nAccess an enum.\nHelper for accessing the inner data of a schema ref at …\nHelper for accessing the inner data of a schema ref at …\nSchema data for an enum.\nA type for an enum tag for <code>EnumSchemaInfo</code>.\nAn <code>f32</code>\n<code>f32</code>\nAn <code>f32</code>\nAn <code>f64</code>\n<code>f64</code>\nAn <code>f64</code>\nThe index of a field in a struct in a <code>Schema</code>.\nA wrapper type that implements […\nTrait implemented for types that can produce an instance …\nDetermines the kind of PRNG. <code>TurboKind::FAST</code> RNGs are …\nThis trait provides the means to easily generate all …\nTrait implemented for types that have a <code>Schema</code>.\nDerive macro for the HasSchema trait.\nA <code>HashMap</code> implementing aHash, a high speed keyed hashing …\nA <code>HashSet</code> implementing aHash, a high speed keyed hashing …\nAn <code>i128</code>\n<code>i128</code>\nAn <code>i128</code>\nAn <code>i16</code>\n<code>i16</code>\nAn <code>i16</code>\nAn <code>i32</code>\n<code>i32</code>\nAn <code>i32</code>\nAn <code>i64</code>\n<code>i64</code>\nAn <code>i64</code>\nAn <code>i8</code>\n<code>i8</code>\nAn <code>i8</code>\nThe index of a field. Works for tuple fields and named …\nThe ID is in the wrong format.\nA <code>Ulid</code> with a human-readable ascii prefix.\nError creating a <code>LabeledId</code>.\nErrors that can happen while parsing a <code>LabeledId</code>.\nThe display error message for this error type.\nAccess a map.\nType represents a <code>SchemaMap</code>.\nAccess a map.\nThe name of a field.\nAn opaque type\nOpaque data that cannot described by a schema.\nAn opaque type\nThe prefix was not ASCII.\nThe prefix was too long ( greater than 63 chars ).\nA type of primitive.\nAccess a struct.\nThe type represents a primitive value.\nAccess a struct.\nHelper for accessing the inner data of a schema ref at …\nHelper for accessing the inner data of a schema ref at …\nThe number of bits in a Ulid’s random portion\nWrapper for a borrowed <code>AtomicCell</code> that will released lock …\nWrapper for mutably borrowed <code>AtomicCell</code> that will released …\nA typed version of <code>SchemaBox</code>.\nGlobal <code>SchemaRegistry</code> used to register <code>SchemaData</code>s and …\nTyped version of a <code>SchemaMap</code>.\nA typed version of a <code>SchemaVec</code>.\nA owning, type-erased <code>Box</code>-like container for types with a …\nSchema information describing the memory layout of a type.\nDerivable schema <code>type_data</code> for types that implement …\nA struct that implements <code>DeserializeSeed</code> and can be used …\nError returned when a field is not found in a schema.\nA unique identifier for a schema registered in the …\nA schema describes the data layout of a type, to enable …\nLayout information computed for <code>SchemaData</code>.\nUntyped schema-aware “HashMap”.\nAccess helper for a <code>SchemaMap</code>.\nMutable <code>SchemaMap</code> access helper.\nError type when attempting to cast between types with …\nAn untyped reference that knows the <code>Schema</code> of the pointee …\nHelper for accessing the inner data of a schema ref at …\nAn untyped mutable reference that knows the <code>Schema</code> of the …\nAccess a schema\nA schema registry that alloates <code>SchemaId</code>s for <code>SchemaData</code>s …\nA struct that implements <code>Serialize</code> and wraps around a …\nA type-erased <code>Vec</code>-like collection that for items with the …\nAccess helper for a <code>SchemaVec</code>.\nMutable <code>SchemaVec</code> access helper.\nA <code>String</code>\nA Rust <code>String</code>. Must be manipulated with Rust string …\nA <code>String</code>\nAccess a struct.\nThe type represents a struct.\nAccess a struct.\nA field in a <code>StructSchemaInfo</code>.\nHelper for accessing the inner data of a schema ref at …\nIterator for <code>StructRefAccess::fields()</code>.\nA field returned by <code>StructRefFieldIter</code>.\nHelper for accessing the inner data of a schema ref at …\nIterator for <code>StructRefAccess::fields()</code>.\nA field returned by <code>StructRefFieldIter</code>.\nSchema data for a struct.\nA fast, non-cryptographic, thread-local random number …\nThe number of bits in a Ulid’s time portion\nExtension trait for automatically implementing all …\nA <code>u128</code>\n<code>u128</code>\nA <code>u128</code>\nA <code>u16</code>\nA <code>u16</code>.\n<code>u16</code>\nA <code>u16</code>\nA <code>u32</code>\nA <code>u32</code>.\n<code>u32</code>\nA <code>u32</code>\nA <code>u64</code>\n<code>u64</code>\nA <code>u64</code>\nA <code>u8</code>\nA <code>u8</code>.\n<code>u8</code>\nA <code>u8</code>\nA Ulid is a unique 128-bit lexicographically sortable …\nThe ULID could not be parsed.\nExtension trait for <code>Ulid</code>.\nA wrapper struct that marks it unsafe to both create and …\nInformation about an enum variant for <code>EnumSchemaInfo</code>.\nAccess a vec.\nType represents a <code>SchemaVec</code>, where each item in the vec …\nAccess a vec.\nGet a helper to access the inner data.\nGet a mutable access helper to this reference.\nGenerates a random <code>char</code> in ranges a-z and A-Z.\nGenerates a random <code>char</code> in ranges a-z, A-Z and 0-9.\nCreates a Crockford Base32 encoded string that represents …\nBorrow the schema ref as a <code>SchemaBox</code> if it is one.\nDereferences and returns result wrapped in the <code>Ref</code>.\nDereferences and returns result wrapped in the <code>RefMut</code>.\nGet the enum, if this is a enum.\nBorrow the schema ref as a <code>SchemaMap</code> if it is one.\nConverts reference and returns result wrapped in the <code>RefMut</code>…\nBorrow this box as a <code>SchemaRefMut</code>.\nConvert back to a <code>SchemaRefMut</code>\nGet the primitive, if this is a primitive.\nReturns a raw pointer to the underlying data in this cell.\nGet the raw pointer\nGet a raw pointer to the box data.\nGet the pointer.\nConverts reference and returns result wrapped in the <code>Ref</code>.\nBorrow this <code>SchemaRefMut</code> as a <code>SchemaRef</code>.\nBorrow this <code>SchemaRefMutAccess</code> as a <code>SchemaRefAccess</code>.\nConvert to an immutable <code>PrimitiveRef</code>.\nBorrow this box as a <code>SchemaRef</code>.\nConverts a reference of <code>T</code> to a <code>SchemaRefMut</code>\nConverts a reference of <code>T</code> to a <code>SchemaRef</code>\nConvert to a <code>SchemaRef</code>.\nGet the struct, if this is a struct.\nGet the schema of the items in the vector, if this is a …\nBorrow the schema ref as a <code>SchemaVec</code> if it is one.\nReturns if all bits are set.\nBitwise AND.\nBitwise AND after NOT of rhs.\nReturns if any bits are set.\nConditionally sets or resets the given bit.\nCounts the number of set bits.\nReturns if the two bitsets have no bits in common.\nReturns if the two bitsets are equal.\nFlips the given bit.\nFormat the bits.\nInitializes all bits.\nReturns total number of bits.\nBitwise combine with MASK.\nReturns if none of the bits are set.\nBitwise NOT.\nBitwise OR.\nResets the given bit.\nSets the given bit.\nReturns if self is a subset of rhs.\nReturns if self is a superset of rhs.\nReturns if the given bit is set.\nBitwise XOR.\nReturns a random boolean value.\nThis module contains types that can be used to implement …\nImmutably borrows the wrapped value.\nMutably borrows the wrapped value.\nGet the capacity of the backing buffer.\nGet the capacity of the vec.\nCast a reference of this type to a reference of another …\nCast this pointer to a reference to a type with a matching …\nCast this box to it’s inner type and return it.\nCast this pointer to a mutable reference to a type with a …\nCast this pointer to a mutable reference.\nUnsafely convert this box into an owned T.\nUnsafely cast this pointer to a specifc Rust type.\nCast a mutable reference of this type to a reference of …\nCast this pointer to a reference to a type with a matching …\nCast this box to a mutable reference to a type with a …\nCast this pointer to a mutable reference.\nCast this box to a reference to a type with a …\nUnsafely cast this pointer to a specifc Rust type.\nReturns a boolean value based on a rate. <code>rate</code> represents …\nGenerates a random <code>char</code> in the given range.\nClears the vector, removing all values.\nClears the vector, removing all values.\nThe function pointer that may be used to clone data with …\nClone this schema ref into a new box.\nCalculate the layout of the type represented by the schema.\nReturns true if the map contains a value for the specified …\nConstructor that) is the same as <code>Ulid::new()</code>, but that …\nGets the datetime of when this Ulid was created accurate …\nDebug format the value stored in the schema box.\nAn ergonomic abbreviation for <code>Default::default()</code> to make …\nCreate a new <code>SchemaBox</code> for a type with a <code>Schema</code> that has a …\nThe function pointer that may be used to write a default …\nUse this <code>SchemaDeserialize</code> to deserialize data from the …\nThe function that may be used to deserialize the type.\nGenerate a random digit in the given <code>radix</code>.\nThe function pointer that may be used to drop data with …\nThe function pointer that may be used to compare two …\nExtends the vector with the contents of an iterator.\nReturns a random <code>f32</code> value between <code>0.0</code> and <code>1.0</code>.\nReturns a random <code>f32</code> value between <code>-1.0</code> and <code>1.0</code>.\nReturns a random <code>f32</code> value between <code>0.0</code> and <code>1.0</code>.\nReturns a random <code>f32</code> value between <code>-1.0</code> and <code>1.0</code>.\nGet the reference to a field.\nGet field with the given index.\nGet the reference to a field.\nGet field with the given index.\nAccess a field, if it exists.\nIf this is a struct, then the field offsets will contain …\nGet the field pointed to by the given path.\nGet the field pointed to by the given path.\nGet the field pointed to by the given path.\nGet the field pointed to by the given path.\nIterate over fields in the struct.\nInterate over the fields on the struct.\nThe fields in the struct, in the order they are defined.\nMakes a new <code>Ref</code> for an optional component of the borrowed …\nMakes a new <code>RefMut</code> for an optional component of the …\nReturns a reference to the first element of the vector, or …\nReturns a mutable reference to the first element of the …\nDeallocate the memory stored in the box, but don’t run …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a Ulid using the provided bytes array.\nCreates a new Ulid with the given datetime\nCreates a new Ulid with the given datetime and random …\nCreate a Ulid from separated parts.\nCreate a new <code>SchemaRefMut</code> from a raw pointer and it’s …\nCreate a new <code>SchemaRef</code> from a raw pointer and it’s …\nCreate a new <code>SchemaBox</code> from raw parts.\nCreates a Ulid from a Crockford Base32 encoded string\nReturn the data for the type.\nThe full name of the type, including any module specifiers.\nReturns an array of constant <code>SIZE</code> containing random <code>u8</code> …\nReturns a random <code>i128</code> value.\nReturns a random <code>i16</code> value.\nReturns a random <code>i32</code> value.\nReturns a random <code>i64</code> value.\nReturns a random <code>i8</code> value.\nReturns a random <code>isize</code> value.\nReturns a random <code>u128</code> value.\nReturns a random <code>u16</code> value.\nReturns a random <code>u32</code> value.\nReturns a random <code>u64</code> value.\nReturns a random <code>u8</code> value.\nReturns a random <code>usize</code> value.\nGet an item in the vec.\nGet a reference to an item in the map.\nUnsafely get the inner value.\nGet an item from the vec.\nGet a value out of the map for the given key.\nReturns a mutable reference to the underlying data.\nGet an item in the vec.\nGet a mutable reference to an item in the map.\nGet an item from the vec.\nGet a value out of the map for the given key.\nGet the item with the given index.\nGet an untyped reference to an item in the map.\nGet an item with the given index.\nGet an untyped reference to an item in the map.\nSafety\nSafety\nShortens a type name to remove all module paths.\nRecursively checks whether or not the schema contains any …\nGet the hash of this <code>SchemaVec</code>.\nGet the hash of this schema box, if supported.\nGet the hash of this schema box.\nGet the hash of the <code>SVec</code>.\nGet the hash of this schema box, if supported.\nThe function pointer that may be used to hash the value.\nReturns a random <code>i128</code> within a given range bound.\nReturns a random <code>i16</code> value.\nReturns a random <code>i32</code> value.\nReturns a random <code>i64</code> value.\nReturns a random <code>i8</code> value.\nIncrement the random number, make sure that the ts millis …\nReturns a <code>usize</code> value for stable indexing across different …\nGet the <code>StructSchemaInfo</code> for this struct.\nGet the enum schema info.\nGet the <code>StructSchemaInfo</code> for this struct.\nGet the enum schema info.\nInsert an entry into the map, returning the previous …\nInsert an item into the map.\nInsert an untyped item into the map.\nSafety\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into an accessor for the inner data.\nBorrow the schema ref as a <code>SchemaBox</code> if it is one.\nGet the reference to a field.\nAccess a field, if it exists.\nGet the field pointed to by the given path.\nConsume to create an iterator over fields in the struct.\nConsumes the <code>AtomicCell</code>, returning the wrapped value.\nBorrow the schema ref as a <code>SchemaMap</code> if it is one.\nConvert into an <code>SBox</code> if the schema of T matches.\nConvert into a <code>SchemaBox</code>\nConvert into an untyped <code>SchemaMap</code>.\nBorrow this <code>SchemaRefMutAccess</code> as a <code>SchemaRefAccess</code>.\nConvert back to a <code>SchemaRefMut</code>\nConvert back to a <code>SchemaRefMut</code>\nConvert this to a <code>SchemaRefMut</code>.\nConvert back to a <code>SchemaRefMut</code>\nConvert to an untyped <code>SchemaVec</code>.\nConvert into a typed <code>SMap</code>.\nSplits wrapper into two parts. One is reference to the …\nSplits wrapper into two parts. One is reference to the …\nConvert into a typed <code>SVec</code>.\nBorrow the schema ref as a <code>SchemaVec</code> if it is one.\nReturns <code>true</code> if the vector has zero items in it.\nReturns true if the map contains no elements.\nReturns <code>true</code> if there are no items in the vector.\nReturns <code>true</code> if the map is empty.\nTest if the Ulid is nil\nReturns a random <code>isize</code> within a given range bound.\nIterate over values in the vec\nIterate over entries in the map.\nIterate over references to the items in the vec.\nIterate over entries in the map.\nIterate mutably over values in the vec\nIterate over entries in the map.\nIterate over mutable references to the items in the vec.\nIterate over entries in the map.\nGet the schema for the map keys.\nIterate over keys in the map.\nIterate over keys in the map.\nThe kind of schema.\nReturns a reference to the last element of the vector, or …\nReturns a mutable reference to the last element of the …\nGet the memory layout of the enum tag.\nThe layout of the type.\nConvert into a reference to the underlying data.\nConvert into a reference to the underlying data.\nGet the number of items in the vector.\nReturns the number of elements in the map.\nGet the length of the vector.\nGet the number of entries in the map.\nHints to the compiler that the branch condition is likely …\nGenerates a random <code>char</code> in the range a-z.\nMakes a new <code>Ref</code> for a component of the borrowed data.\nMakes a new <code>RefMut</code> for a component of the borrowed data.\nSplits a <code>Ref</code> into multiple <code>Ref</code>s for different components …\nSplits a <code>RefMut</code> into multiple <code>RefMut</code>s for different …\nThe name of the field, if set.\nThe name of the field, if set.\nThe short name of the type.\nThe name of the enum variant.\nThe name of the field. Will be <code>None</code> if this is a field of …\nCreates a new <code>AtomicCell</code> containing value.\nCreate a new labeled ID with the given prefix.\nWraps external reference into <code>Ref</code>.\nInitialize an empty <code>SchemaVec</code> for items with the given …\nCreates a new Ulid with the current time (UTC)\nWraps external reference into <code>RefMut</code>.\nInitialize the <code>SMap</code>.\nCreate a new <code>SchemaRefMut</code> from a reference to a type that …\nCreate a new <code>SchemaRefAccess</code> for the given <code>SchemaRef</code>.\nCreate a new <code>SchemaBox</code> from an owned type.\nCreate a new <code>SBox</code>.\nCreate a new <code>Unsafe</code> contianing the <code>value</code>.\nCreate a new, empty <code>SVec</code>.\nCreate a new map, with the given key and value schemas.\nCreate a new <code>SchemaRef</code> from a reference to a type that …\nCreate a new <code>SchemaRefAccess</code> for the given <code>SchemaRef</code>.\nCreate a new <code>SchemaRefAccess</code> for the given <code>SchemaRef</code> that …\nCreate a new <code>SchemaRefAccess</code> for the given <code>SchemaRef</code> that …\nCreate a new labeled ID with the given prefix and ULID.\nThe ‘nil Ulid’.\nPartially shuffles a slice by a given amount and returns …\nPop an item off the vec.\nPop an item off of the vector.\nPop the last item off of the end of the vector.\nRemoves and returns the last element of the vector if the …\nGet the prefix of the ID.\nPush an item to the vec.\nPush an item onto the vector.\nPush the item into the end of the vector.\nGets the random section of this ulid\nRaw version of the <code>eq()</code> function. Not meant for normal use.\nRaw version of the <code>hash()</code> function. Not meant for normal …\nConvert a borrowed <code>SchemaRefMut</code> to an owned <code>SchemaRefMut</code> …\nRegister a schema with the registry.\nRegister this schema with the global schema registry.\nRemove and return the element at position <code>index</code> within the …\nRemove an item from the map.\nRemove and return the element at position <code>index</code> within the …\nRemove an item.\nUntypededly remove an item.\nSafety\nReplaces the wrapped value with a new one, returning the …\nReplaces the wrapped value with a new one computed from f, …\nRetains only the elements specified by the predicate.\nRetains only the elements specified by the predicate, …\nReverses the order of elements in the vector, in place.\nSamples a random item from a slice of values.\nSamples a random item from an iterator of values. <code>O(1)</code> if …\nSamples multiple unique items from a slice of values.\nSamples multiple unique items from an iterator of values.\nSamples multiple unique items from a mutable slice of …\nSamples a random <code>&amp;mut</code> item from a slice of values.\nGet this type’s <code>Schema</code>.\nGet the schema of items in this <code>SchemaVec</code>.\nGet the <code>Schema</code> for the pointer.\nGet the struct’s schema.\nGet the enum’s schema.\nGet the <code>Schema</code> for the pointer.\nGet the <code>Schema</code> for the pointer.\nGet the struct’s schema.\nGet the enum’s schema.\nThe schema of this variant.\nThe schema of the field.\nThe registered schemas.\nShuffles a slice randomly in O(n) time.\nMakes a new <code>Ref</code> for a sub-slice of the borrowed slice.\nMakes a new <code>RefMut</code> for a sub-slice of the borrowed slice.\nSwaps the wrapped value of self with the wrapped value of …\nThe layout of the enum tag.\nTakes the wrapped value, leaving <code>Default::default()</code> in its …\nGets the timestamp section of this ulid\nReturns the bytes of the Ulid in big-endian order.\nCreates a Crockford Base32 encoded string that represents …\nCreates a Crockford Base32 encoded string that represents …\nTransposes a <code>Ref</code> of an <code>Option</code> into an <code>Option</code> of a <code>Ref</code>. …\nTransposes a <code>RefMut</code> of an <code>Option</code> into an <code>Option</code> of a <code>RefMut</code>…\nShortens the vector, keeping the first <code>len</code> elements and …\nShortens the vector, keeping the first <code>len</code> elements and …\nImmutably borrows the wrapped value, returning <code>None</code> if the …\nMutably borrows the wrapped value, returning an error if …\nImmutably borrows the wrapped value, returning <code>None</code> if the …\nMutably borrows the wrapped value, returning <code>None</code> if the …\nCast a reference of this type to a reference of another …\nCast this pointer to a reference to a type with a matching …\nCast this box to it’s inner type and return it.\nCast this pointer to a mutable reference to a type with a …\nCast a mutable reference of this type to a reference of …\nCast this pointer to a mutable reference to a type with a …\nCast this box to a mutable reference to a type with a …\nCast this box to a reference to a type with a …\nGet an item in the vec.\nGet a value out of the map for the given key.\nGet an item in the vec.\nGet a value out of the map for the given key.\nGet an untyped reference to an item in the map.\nGet an untyped reference to an item in the map.\nGet the hash of this schema box, if supported.\nInsert an item into the map.\nInsert an untyped item into the map.\nConvert into an <code>SBox</code> if the schema of T matches.\nConvert into a typed <code>SMap</code>.\nTry to convert into a typed <code>SVec</code>.\nPop an item off the vec.\nPush an item to the vec.\nPush the item into the end of the vector.\nRemove an item.\nUntypededly remove an item.\nContainer for storing <code>Schema</code> type datas.\nThe Rust <code>TypeId</code> that this <code>Schema</code> was created from, if it …\nReturns a random <code>u128</code> within a given range bound.\nReturns a random <code>u16</code> value.\nReturns a random <code>u32</code> value.\nReturns a random <code>u64</code> value.\nReturns a random <code>u8</code> value.\nGet the <code>Ulid</code> of the ID.\nUndo the effect of leaked guards on the borrow state of …\nAllocates a <code>SchemaBox</code> for the given <code>Schema</code>, but <strong>doesn’t </strong>…\nHints to the compiler that the branch condition is …\nGenerates a random <code>char</code> in the range A-Z.\nReturns a random <code>usize</code> within a given range bound.\nGet a reference to the enum’s currently selected value.\nGet a reference to the enum’s currently selected value.\nThe field’s value.\nThe field’s value.\nGet the schema for the map values.\nIterate over values in the map.\nIterate over values in the map.\nIterate over values in the map.\nIterate over values in the map.\nGet the currently-selected variant index.\nGet the currently-selected variant index.\nGet the <code>VariantInfo</code> for the current variant.\nGet the name of the currently selected variant.\nGet the name of the currently selected variant.\nGet the <code>StructSchemaInfo</code> for the current variant.\nInfo for the enum variants.\nStochastic Acceptance implementation of Roulette Wheel …\nStochastic Acceptance implementation of Roulette Wheel …\nWraps external reference into <code>Ref</code>. And associates it with …\nWraps external reference into <code>RefMut</code>. And associates it …\nCreates a new Ulid using data from the given random number …\nClone <code>other</code> and write it’s data to <code>self</code>. Panics if this …\nThe alignment of the data.\nThe size of the data.\nThe align of the opaque type.\nThe schema ref.\nThe size of the opaque type.\nThe align of the opaque type.\nThe schema ref.\nThe size of the opaque type.\nThe schema of the key type.\nThe schema of the value type.\nError creating ID\nDerive macro for deriving <code>Deref</code> on structs with one field.\nDerive macro for deriving <code>DerefMut</code> on structs with one …\nDetermines the kind of PRNG. <code>TurboKind::FAST</code> RNGs are …\nThis trait provides the means to easily generate all …\nA <code>HashMap</code> implementing aHash, a high speed keyed hashing …\nA <code>HashSet</code> implementing aHash, a high speed keyed hashing …\nThe ID is in the wrong format.\nA <code>Ulid</code> with a human-readable ascii prefix.\nError creating a <code>LabeledId</code>.\nErrors that can happen while parsing a <code>LabeledId</code>.\nThe prefix was not ASCII.\nThe prefix was too long ( greater than 63 chars ).\nA fast, non-cryptographic, thread-local random number …\nExtension trait for automatically implementing all …\nA Ulid is a unique 128-bit lexicographically sortable …\nThe ULID could not be parsed.\nExtension trait for <code>Ulid</code>.\nGenerates a random <code>char</code> in ranges a-z and A-Z.\nGenerates a random <code>char</code> in ranges a-z, A-Z and 0-9.\nReturns a random boolean value.\nReturns a boolean value based on a rate. <code>rate</code> represents …\nGenerates a random <code>char</code> in the given range.\nConstructor that) is the same as <code>Ulid::new()</code>, but that …\nAn ergonomic abbreviation for <code>Default::default()</code> to make …\nGenerate a random digit in the given <code>radix</code>.\nReturns a random <code>f32</code> value between <code>0.0</code> and <code>1.0</code>.\nReturns a random <code>f32</code> value between <code>-1.0</code> and <code>1.0</code>.\nReturns a random <code>f32</code> value between <code>0.0</code> and <code>1.0</code>.\nReturns a random <code>f32</code> value between <code>-1.0</code> and <code>1.0</code>.\nReturns an array of constant <code>SIZE</code> containing random <code>u8</code> …\nReturns a random <code>i128</code> value.\nReturns a random <code>i16</code> value.\nReturns a random <code>i32</code> value.\nReturns a random <code>i64</code> value.\nReturns a random <code>i8</code> value.\nReturns a random <code>isize</code> value.\nReturns a random <code>u128</code> value.\nReturns a random <code>u16</code> value.\nReturns a random <code>u32</code> value.\nReturns a random <code>u64</code> value.\nReturns a random <code>u8</code> value.\nReturns a random <code>usize</code> value.\nShortens a type name to remove all module paths.\nReturns a random <code>i128</code> within a given range bound.\nReturns a random <code>i16</code> value.\nReturns a random <code>i32</code> value.\nReturns a random <code>i64</code> value.\nReturns a random <code>i8</code> value.\nReturns a <code>usize</code> value for stable indexing across different …\nReturns a random <code>isize</code> within a given range bound.\nGenerates a random <code>char</code> in the range a-z.\nPartially shuffles a slice by a given amount and returns …\nThe prelude.\nSamples a random item from a slice of values.\nSamples a random item from an iterator of values. <code>O(1)</code> if …\nSamples multiple unique items from a slice of values.\nSamples multiple unique items from an iterator of values.\nSamples multiple unique items from a mutable slice of …\nSamples a random <code>&amp;mut</code> item from a slice of values.\nShuffles a slice randomly in O(n) time.\nReturns a random <code>u128</code> within a given range bound.\nReturns a random <code>u16</code> value.\nReturns a random <code>u32</code> value.\nReturns a random <code>u64</code> value.\nReturns a random <code>u8</code> value.\nGenerates a random <code>char</code> in the range A-Z.\nReturns a random <code>usize</code> within a given range bound.\nStochastic Acceptance implementation of Roulette Wheel …\nStochastic Acceptance implementation of Roulette Wheel …\nError creating ID\nDerive macro for deriving <code>Deref</code> on structs with one field.\nDerive macro for deriving <code>DerefMut</code> on structs with one …\nDetermines the kind of PRNG. <code>TurboKind::FAST</code> RNGs are …\nThis trait provides the means to easily generate all …\nA <code>HashMap</code> implementing aHash, a high speed keyed hashing …\nA <code>HashSet</code> implementing aHash, a high speed keyed hashing …\nThe ID is in the wrong format.\nA <code>Ulid</code> with a human-readable ascii prefix.\nError creating a <code>LabeledId</code>.\nErrors that can happen while parsing a <code>LabeledId</code>.\nThe prefix was not ASCII.\nThe prefix was too long ( greater than 63 chars ).\nA fast, non-cryptographic, thread-local random number …\nExtension trait for automatically implementing all …\nA Ulid is a unique 128-bit lexicographically sortable …\nThe ULID could not be parsed.\nExtension trait for <code>Ulid</code>.\nGenerates a random <code>char</code> in ranges a-z and A-Z.\nGenerates a random <code>char</code> in ranges a-z, A-Z and 0-9.\nReturns a random boolean value.\nReturns a boolean value based on a rate. <code>rate</code> represents …\nGenerates a random <code>char</code> in the given range.\nConstructor that) is the same as <code>Ulid::new()</code>, but that …\nAn ergonomic abbreviation for <code>Default::default()</code> to make …\nGenerate a random digit in the given <code>radix</code>.\nReturns a random <code>f32</code> value between <code>0.0</code> and <code>1.0</code>.\nReturns a random <code>f32</code> value between <code>-1.0</code> and <code>1.0</code>.\nReturns a random <code>f32</code> value between <code>0.0</code> and <code>1.0</code>.\nReturns a random <code>f32</code> value between <code>-1.0</code> and <code>1.0</code>.\nReturns an array of constant <code>SIZE</code> containing random <code>u8</code> …\nReturns a random <code>i128</code> value.\nReturns a random <code>i16</code> value.\nReturns a random <code>i32</code> value.\nReturns a random <code>i64</code> value.\nReturns a random <code>i8</code> value.\nReturns a random <code>isize</code> value.\nReturns a random <code>u128</code> value.\nReturns a random <code>u16</code> value.\nReturns a random <code>u32</code> value.\nReturns a random <code>u64</code> value.\nReturns a random <code>u8</code> value.\nReturns a random <code>usize</code> value.\nShortens a type name to remove all module paths.\nReturns a random <code>i128</code> within a given range bound.\nReturns a random <code>i16</code> value.\nReturns a random <code>i32</code> value.\nReturns a random <code>i64</code> value.\nReturns a random <code>i8</code> value.\nReturns a <code>usize</code> value for stable indexing across different …\nReturns a random <code>isize</code> within a given range bound.\nGenerates a random <code>char</code> in the range a-z.\nPartially shuffles a slice by a given amount and returns …\nSamples a random item from a slice of values.\nSamples a random item from an iterator of values. <code>O(1)</code> if …\nSamples multiple unique items from a slice of values.\nSamples multiple unique items from an iterator of values.\nSamples multiple unique items from a mutable slice of …\nSamples a random <code>&amp;mut</code> item from a slice of values.\nShuffles a slice randomly in O(n) time.\nReturns a random <code>u128</code> within a given range bound.\nReturns a random <code>u16</code> value.\nReturns a random <code>u32</code> value.\nReturns a random <code>u64</code> value.\nReturns a random <code>u8</code> value.\nGenerates a random <code>char</code> in the range A-Z.\nReturns a random <code>usize</code> within a given range bound.\nStochastic Acceptance implementation of Roulette Wheel …\nStochastic Acceptance implementation of Roulette Wheel …\nEncapsulates shared borrowing state.\nEncapsulates exclusive borrowing state.\nLock type used by [<code>AtomicCell</code>].\nReturns true if there are too many read refs.\nReturns true if there are too many write refs.\nBorrows can be cloned.\nBorrows can be cloned.\nClones immutable borrow of specified lock. This function …\nClones mutable borrow of specified lock. This function …\nReturns dummy atomic borrow that doesn’t actually locks …\nReturns dummy atomic borrow that doesn’t actually locks …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if specified lock value is borrowed.\nReturns true if specified lock value is borrowed immutably.\nReturns true if specified lock value is borrowed mutably.\nCreate atomic borrow lock. Initially not borrowed.\nReleases immutable borrow of specified lock. This function …\nReleases mutable borrow of specified lock. This function …\nRestore previously leaked <code>AtomicBorrow</code> instance.\nRestore previously leaked <code>AtomicBorrowMut</code> instance.\nAttempts to borrow specified lock immutably.\nAttempts to borrow specified lock mutably.\nAttempts to borrow lock immutably.\nAttempts to borrow lock mutably.\nA handle to a resource from a <code>Resources</code> collection.\nAn untyped, atomic resource cell.\nError thrown when a resource cell cannot be inserted …\nA collection of resources.\nAn untyped resource that may be inserted into …\nStorage for un-typed resources.\nBorrow the resource.\nLock the resource for reading.\nMutably borrow the resource.\nLock the resource for read-writing.\nClone the inner data, creating a new copy instead of …\nCheck whether or not the resource with the given ID is …\nCheck whether or not a resource is in the store.\nCheck whether or not a cell for the given resource has …\nInitialize a new, empty <code>UntypedResource</code>.\nCreate a new, empty resource cell.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>UntypedResource</code> for the given schema, …\nCreate from an <code>UntypedResource</code>.\nBorrow the resource for the given schema.\nBorrow a resource.\nGet a cell for the resource with the given schema.\nGets a clone of the resource cell for the resource of the …\nBorrow a resource.\nInitialize the resource using it’s <code>FromWorld</code> …\nBorrow the resource, initializing it if it doesn’t exist.\nBorrow the resource, initializing it if it doesn’t exist.\nInsert resource data into the cell, returning the previous …\nInsert a resource.\nThis is an advanced use-case function that allows you to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume <code>Resources</code> and extract the underlying …\nConvert into an untyped resource.\nCreates a new <code>UntypedResource</code> storing the given data.\nCreate an empty <code>UntypedResources</code>.\nCreate an empty <code>Resources</code>.\nCreate a new resource cell with the given data.\nRemove the resource data, returning what was stored in it.\nRemove a resource from the store, if it is present.\nRemove the resource from the cell, leaving the cell empty.\nGet the schema of the resource.\nBorrow the underlying <code>UntypedResources</code> store.\nA resource containing the <code>Commands</code> command queue.\nA <code>SystemParam</code> that can be used to schedule systems that …\nA <code>StageLabel</code> for the 5 core stages.\nResource that is automatically added to the world while a …\nThe first stage\nThe fifth stage\nThe fourth stage\nThe second stage\nA collection of systems that will be run in order.\nTrait for things that may be used to identify a system …\nTrait for system stages. A stage is a\nAn ordered collection of <code>SystemStage</code>s.\nThe third stage\nAdd a system to be run at the end of the stage.\nAdd a system that will run each frame until it succeeds …\nAdd a system that will run only once, before all of the …\nAdd a system to this stage.\nAdd a <code>System</code> to the stage with the given label.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether or not the startup systems have been run yet.\nThe unique identifier for the stage.\nReturns a unique identifier for the stage.\nThe unique identifier for the stage.\nInsert a new stage, after another existing stage\nInsert a new stage, before another existing stage\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe human-readable name for the stage, used for error …\nReturns the human-readable name of the label, used in …\nThe human-readable name for the stage, used for error …\nCreate a new, empty stage, for the given label.\nThe system queue that will be run at the end of the stage\nRemove all systems from this stage.\nRemove all systems from all stages, including startup and …\nRemove all systems from all stages, including startup and …\nExecute the systems on the given <code>world</code>.\nExecute the systems on the given <code>world</code>.\nSystems that are continously run until they succeed(return …\nThe stages in the collection, in the order that they will …\nThe systems that should run at startup.\nThe list of systems in the stage.\nCreate a <code>SystemStages</code> collection, initialized with a stage …\n<code>SystemParam</code> for getting read access to a <code>ComponentStore</code>.\n<code>SystemParam</code> for getting mutable access to a <code>ComponentStore</code>.\nThe system input parameter.\nConverts a function into a <code>System</code>.\nThe type of the parameter, ranging over the lifetime of …\n<code>SystemParam</code> for getting read access to a resource.\n<code>SystemParam</code> for getting read access to a resource and …\n<code>SystemParam</code> for getting mutable access to a resource.\n<code>SystemParam</code> for getting mutable access to a resource and …\nThe intermediate state for the parameter, that may be …\nStruct containing a static system.\nThe type of the system that is output\nTrait implemented by systems.\nTrait used to implement parameters for <code>System</code> functions.\nThis is used create an instance of the system parame, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis is called to produce the intermediate state of the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet a best-effort name for the system, used in diagnostics.\nA best-effort name for the system, for diagnostic purposes.\nRun the system.\nThis is run every time the system is executed\nConvert into a <code>System</code>.")