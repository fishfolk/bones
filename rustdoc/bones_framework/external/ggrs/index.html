<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="GGRS"><title>bones_framework::external::ggrs - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="bones_framework" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../../crates.js"></script><script defer src="../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../bones_framework/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../bones_framework/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate ggrs</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.3.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a href="../../index.html">bones_framework</a>::<wbr><a href="../index.html">external</a>::<wbr><a class="mod" href="#">ggrs</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="ggrs"><a href="#ggrs">GGRS</a></h2>
<p>GGRS (good game rollback system) is a reimagination of the GGPO network SDK written in 100% safe Rust ðŸ¦€.
The callback-style API from the original library has been replaced with a much saner, simpler control flow.
Instead of registering callback functions, GGRS returns a list of requests for the user to fulfill.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.GameStateCell.html" title="struct bones_framework::external::ggrs::GameStateCell">GameStateCell</a></div><div class="desc docblock-short">An <a href="../../asset/prelude/bones_utils/prelude/alloc/sync/struct.Arc.html" title="struct bones_framework::asset::prelude::bones_utils::prelude::alloc::sync::Arc"><code>Arc&lt;Mutex&gt;</code></a> that you can <a href="struct.GameStateCell.html#method.save" title="struct bones_framework::external::ggrs::GameStateCell"><code>save()</code></a>/<a href="struct.GameStateCell.html#method.load" title="struct bones_framework::external::ggrs::GameStateCell"><code>load()</code></a> a <code>T</code> to/from. These will be handed to the user as part of a <a href="enum.GGRSRequest.html" title="enum bones_framework::external::ggrs::GGRSRequest"><code>GGRSRequest</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Message.html" title="struct bones_framework::external::ggrs::Message">Message</a></div><div class="desc docblock-short">A messages that <a href="trait.NonBlockingSocket.html" title="trait bones_framework::external::ggrs::NonBlockingSocket"><code>NonBlockingSocket</code></a> sends and receives. When implementing <a href="trait.NonBlockingSocket.html" title="trait bones_framework::external::ggrs::NonBlockingSocket"><code>NonBlockingSocket</code></a>,
you should deserialize received messages into this <code>Message</code> type and pass them.</div></li><li><div class="item-name"><a class="struct" href="struct.NetworkStats.html" title="struct bones_framework::external::ggrs::NetworkStats">NetworkStats</a></div><div class="desc docblock-short">The <code>NetworkStats</code> struct contains statistics about the current session.</div></li><li><div class="item-name"><a class="struct" href="struct.P2PSession.html" title="struct bones_framework::external::ggrs::P2PSession">P2PSession</a></div><div class="desc docblock-short">A <a href="struct.P2PSession.html" title="struct bones_framework::external::ggrs::P2PSession"><code>P2PSession</code></a> provides all functionality to connect to remote clients in a peer-to-peer fashion, exchange inputs and handle the gamestate by saving, loading and advancing.</div></li><li><div class="item-name"><a class="struct" href="struct.SessionBuilder.html" title="struct bones_framework::external::ggrs::SessionBuilder">SessionBuilder</a></div><div class="desc docblock-short">The <a href="struct.SessionBuilder.html" title="struct bones_framework::external::ggrs::SessionBuilder"><code>SessionBuilder</code></a> builds all GGRS Sessions. After setting all appropriate values, use <code>SessionBuilder::start_yxz_session(...)</code>
to consume the builder and create a Session of desired type.</div></li><li><div class="item-name"><a class="struct" href="struct.SpectatorSession.html" title="struct bones_framework::external::ggrs::SpectatorSession">SpectatorSession</a></div><div class="desc docblock-short"><a href="struct.SpectatorSession.html" title="struct bones_framework::external::ggrs::SpectatorSession"><code>SpectatorSession</code></a> provides all functionality to connect to a remote host in a peer-to-peer fashion.
The host will broadcast all confirmed inputs to this session.
This session can be used to spectate a session without contributing to the game input.</div></li><li><div class="item-name"><a class="struct" href="struct.SyncTestSession.html" title="struct bones_framework::external::ggrs::SyncTestSession">SyncTestSession</a></div><div class="desc docblock-short">During a <a href="struct.SyncTestSession.html" title="struct bones_framework::external::ggrs::SyncTestSession"><code>SyncTestSession</code></a>, GGRS will simulate a rollback every frame and resimulate the last n states, where n is the given check distance.
The resimulated checksums will be compared with the original checksums and report if there was a mismatch.</div></li><li><div class="item-name"><a class="struct" href="struct.UdpNonBlockingSocket.html" title="struct bones_framework::external::ggrs::UdpNonBlockingSocket">UdpNonBlockingSocket</a></div><div class="desc docblock-short">A simple non-blocking UDP socket tu use with GGRS Sessions. Listens to 0.0.0.0 on a given port.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.DesyncDetection.html" title="enum bones_framework::external::ggrs::DesyncDetection">DesyncDetection</a></div><div class="desc docblock-short">Desync detection by comparing checksums between peers.</div></li><li><div class="item-name"><a class="enum" href="enum.GGRSError.html" title="enum bones_framework::external::ggrs::GGRSError">GGRSError</a></div><div class="desc docblock-short">This enum contains all error messages this library can return. Most API functions will generally return a <a href="https://doc.rust-lang.org/1.73.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result&lt;(),GGRSError&gt;</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.GGRSEvent.html" title="enum bones_framework::external::ggrs::GGRSEvent">GGRSEvent</a></div><div class="desc docblock-short">Notifications that you can receive from the session. Handling them is up to the user.</div></li><li><div class="item-name"><a class="enum" href="enum.GGRSRequest.html" title="enum bones_framework::external::ggrs::GGRSRequest">GGRSRequest</a></div><div class="desc docblock-short">Requests that you can receive from the session. Handling them is mandatory.</div></li><li><div class="item-name"><a class="enum" href="enum.InputStatus.html" title="enum bones_framework::external::ggrs::InputStatus">InputStatus</a></div><div class="desc docblock-short"><a href="enum.InputStatus.html" title="enum bones_framework::external::ggrs::InputStatus"><code>InputStatus</code></a> will always be given together with player inputs when requested to advance the frame.</div></li><li><div class="item-name"><a class="enum" href="enum.PlayerType.html" title="enum bones_framework::external::ggrs::PlayerType">PlayerType</a></div><div class="desc docblock-short">Defines the three types of players that GGRS considers:</div></li><li><div class="item-name"><a class="enum" href="enum.SessionState.html" title="enum bones_framework::external::ggrs::SessionState">SessionState</a></div><div class="desc docblock-short">A session is always in one of these states. You can query the current state of a session via <a href="struct.P2PSession.html#method.current_state" title="struct bones_framework::external::ggrs::P2PSession"><code>current_state</code></a>.</div></li></ul><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.NULL_FRAME.html" title="constant bones_framework::external::ggrs::NULL_FRAME">NULL_FRAME</a></div><div class="desc docblock-short">Internally, -1 represents no frame / invalid frame.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Config.html" title="trait bones_framework::external::ggrs::Config">Config</a></div><div class="desc docblock-short">Compile time parameterization for sessions.</div></li><li><div class="item-name"><a class="trait" href="trait.NonBlockingSocket.html" title="trait bones_framework::external::ggrs::NonBlockingSocket">NonBlockingSocket</a></div><div class="desc docblock-short">This <a href="trait.NonBlockingSocket.html" title="trait bones_framework::external::ggrs::NonBlockingSocket"><code>NonBlockingSocket</code></a> trait is used when you want to use GGRS with your own socket.
However you wish to send and receive messages, it should be implemented through these two methods.
Messages should be sent in an UDP-like fashion, unordered and unreliable.
GGRS has an internal protocol on top of this to make sure all important information is sent and received.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Frame.html" title="type bones_framework::external::ggrs::Frame">Frame</a></div><div class="desc docblock-short">A frame is a single step of execution.</div></li><li><div class="item-name"><a class="type" href="type.PlayerHandle.html" title="type bones_framework::external::ggrs::PlayerHandle">PlayerHandle</a></div><div class="desc docblock-short">Each player is identified by a player handle.</div></li></ul></section></div></main></body></html>