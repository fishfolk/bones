<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="GGRS"><title>bones_framework::external::ggrs - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="bones_framework" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.0 (254b59607 2026-01-19)" data-channel="1.93.0" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../../../crates.js"></script><script defer src="../../../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate ggrs</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../bones_framework/index.html">bones_<wbr>framework</a><span class="version">0.4.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#ggrs" title="GGRS">GGRS</a></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In bones_<wbr>framework::<wbr>external</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">bones_framework</a>::<wbr><a href="../index.html">external</a></div><h1>Crate <span>ggrs</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="ggrs"><a class="doc-anchor" href="#ggrs">ยง</a>GGRS</h2>
<p>GGRS (good game rollback system) is a reimagination of the GGPO network SDK written in 100% safe Rust ๐ฆ.
The callback-style API from the original library has been replaced with a much saner, simpler control flow.
Instead of registering callback functions, GGRS returns a list of requests for the user to fulfill.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.GameStateCell.html" title="struct bones_framework::external::ggrs::GameStateCell">Game<wbr>State<wbr>Cell</a></dt><dd>An <a href="https://doc.rust-lang.org/1.93.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc"><code>Arc&lt;Mutex&gt;</code></a> that you can <a href="struct.GameStateCell.html#method.save" title="struct bones_framework::external::ggrs::GameStateCell"><code>save()</code></a>/<a href="struct.GameStateCell.html#method.load" title="struct bones_framework::external::ggrs::GameStateCell"><code>load()</code></a> a <code>T</code> to/from. These will be handed to the user as part of a <a href="enum.GgrsRequest.html" title="enum bones_framework::external::ggrs::GgrsRequest"><code>GgrsRequest</code></a>.</dd><dt><a class="struct" href="struct.Message.html" title="struct bones_framework::external::ggrs::Message">Message</a></dt><dd>A messages that <a href="trait.NonBlockingSocket.html" title="trait bones_framework::external::ggrs::NonBlockingSocket"><code>NonBlockingSocket</code></a> sends and receives. When implementing <a href="trait.NonBlockingSocket.html" title="trait bones_framework::external::ggrs::NonBlockingSocket"><code>NonBlockingSocket</code></a>,
you should deserialize received messages into this <code>Message</code> type and pass them.</dd><dt><a class="struct" href="struct.NetworkStats.html" title="struct bones_framework::external::ggrs::NetworkStats">Network<wbr>Stats</a></dt><dd>The <code>NetworkStats</code> struct contains statistics about the current session.</dd><dt><a class="struct" href="struct.P2PSession.html" title="struct bones_framework::external::ggrs::P2PSession">P2PSession</a></dt><dd>A <a href="struct.P2PSession.html" title="struct bones_framework::external::ggrs::P2PSession"><code>P2PSession</code></a> provides all functionality to connect to remote clients in a peer-to-peer fashion, exchange inputs and handle the gamestate by saving, loading and advancing.</dd><dt><a class="struct" href="struct.SessionBuilder.html" title="struct bones_framework::external::ggrs::SessionBuilder">Session<wbr>Builder</a></dt><dd>The <a href="struct.SessionBuilder.html" title="struct bones_framework::external::ggrs::SessionBuilder"><code>SessionBuilder</code></a> builds all GGRS Sessions. After setting all appropriate values, use <code>SessionBuilder::start_yxz_session(...)</code>
to consume the builder and create a Session of desired type.</dd><dt><a class="struct" href="struct.SpectatorSession.html" title="struct bones_framework::external::ggrs::SpectatorSession">Spectator<wbr>Session</a></dt><dd><a href="struct.SpectatorSession.html" title="struct bones_framework::external::ggrs::SpectatorSession"><code>SpectatorSession</code></a> provides all functionality to connect to a remote host in a peer-to-peer fashion.
The host will broadcast all confirmed inputs to this session.
This session can be used to spectate a session without contributing to the game input.</dd><dt><a class="struct" href="struct.SyncTestSession.html" title="struct bones_framework::external::ggrs::SyncTestSession">Sync<wbr>Test<wbr>Session</a></dt><dd>During a <a href="struct.SyncTestSession.html" title="struct bones_framework::external::ggrs::SyncTestSession"><code>SyncTestSession</code></a>, GGRS will simulate a rollback every frame and resimulate the last n states, where n is the given check distance.
The resimulated checksums will be compared with the original checksums and report if there was a mismatch.</dd><dt><a class="struct" href="struct.UdpNonBlockingSocket.html" title="struct bones_framework::external::ggrs::UdpNonBlockingSocket">UdpNon<wbr>Blocking<wbr>Socket</a></dt><dd>A simple non-blocking UDP socket tu use with GGRS Sessions. Listens to 0.0.0.0 on a given port.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="enum" href="enum.DesyncDetection.html" title="enum bones_framework::external::ggrs::DesyncDetection">Desync<wbr>Detection</a></dt><dd>Desync detection by comparing checksums between peers.</dd><dt><a class="enum" href="enum.GgrsError.html" title="enum bones_framework::external::ggrs::GgrsError">Ggrs<wbr>Error</a></dt><dd>This enum contains all error messages this library can return. Most API functions will generally return a <a href="https://doc.rust-lang.org/1.93.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result&lt;(), GgrsError&gt;</code></a>.</dd><dt><a class="enum" href="enum.GgrsEvent.html" title="enum bones_framework::external::ggrs::GgrsEvent">Ggrs<wbr>Event</a></dt><dd>Notifications that you can receive from the session. Handling them is up to the user.</dd><dt><a class="enum" href="enum.GgrsRequest.html" title="enum bones_framework::external::ggrs::GgrsRequest">Ggrs<wbr>Request</a></dt><dd>Requests that you can receive from the session. Handling them is mandatory.</dd><dt><a class="enum" href="enum.InputStatus.html" title="enum bones_framework::external::ggrs::InputStatus">Input<wbr>Status</a></dt><dd><a href="enum.InputStatus.html" title="enum bones_framework::external::ggrs::InputStatus"><code>InputStatus</code></a> will always be given together with player inputs when requested to advance the frame.</dd><dt><a class="enum" href="enum.PlayerType.html" title="enum bones_framework::external::ggrs::PlayerType">Player<wbr>Type</a></dt><dd>Defines the three types of players that GGRS considers:</dd><dt><a class="enum" href="enum.SessionState.html" title="enum bones_framework::external::ggrs::SessionState">Session<wbr>State</a></dt><dd>A session is always in one of these states. You can query the current state of a session via <a href="struct.P2PSession.html#method.current_state" title="struct bones_framework::external::ggrs::P2PSession"><code>current_state</code></a>.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="constant" href="constant.NULL_FRAME.html" title="constant bones_framework::external::ggrs::NULL_FRAME">NULL_<wbr>FRAME</a></dt><dd>Internally, -1 represents no frame / invalid frame.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Config.html" title="trait bones_framework::external::ggrs::Config">Config</a></dt><dd>Compile time parameterization for sessions.</dd><dt><a class="trait" href="trait.NonBlockingSocket.html" title="trait bones_framework::external::ggrs::NonBlockingSocket">NonBlocking<wbr>Socket</a></dt><dd>This <a href="trait.NonBlockingSocket.html" title="trait bones_framework::external::ggrs::NonBlockingSocket"><code>NonBlockingSocket</code></a> trait is used when you want to use GGRS with your own socket.
However you wish to send and receive messages, it should be implemented through these two methods.
Messages should be sent in an UDP-like fashion, unordered and unreliable.
GGRS has an internal protocol on top of this to make sure all important information is sent and received.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="type" href="type.Frame.html" title="type bones_framework::external::ggrs::Frame">Frame</a></dt><dd>A frame is a single step of execution.</dd><dt><a class="type" href="type.PlayerHandle.html" title="type bones_framework::external::ggrs::PlayerHandle">Player<wbr>Handle</a></dt><dd>Each player is identified by a player handle.</dd></dl></section></div></main></body></html>